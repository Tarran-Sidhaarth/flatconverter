// Package flatbuffers implements the conversion of Protocol Buffer (.proto) files
// into FlatBuffer (.fbs) schema files.
package flatbuffers

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/bufbuild/protocompile"
	"github.com/bufbuild/protocompile/reporter"
	"github.com/machanirobotics/buffman/internal/options"
	"github.com/machanirobotics/buffman/internal/template"
	"github.com/machanirobotics/buffman/internal/utilities"
)

// flatbufferCommentPrefix defines the line comment style for FlatBuffer files.
const flatbufferCommentPrefix string = "//"

// FlatbuffersParser handles the conversion of Protocol Buffer files to FlatBuffers schemas.
type FlatbuffersParser struct {
	compiler      *protocompile.Compiler
	protoDir      string
	cleanedDir    string
	flatbufferDir string
}

// NewFlatbuffersParser creates a new parser instance.
func NewFlatbuffersParser() (*FlatbuffersParser, error) {
	tempDir, err := os.MkdirTemp("", "cleaned")
	if err != nil {
		return nil, fmt.Errorf("failed to create temp directory: %w", err)
	}
	return &FlatbuffersParser{
		cleanedDir: tempDir,
	}, nil
}

// Parse orchestrates the end-to-end conversion of .proto files to .fbs files.
func (c *FlatbuffersParser) Parse(ctx context.Context, opts options.ParseOptions) error {
	c.compiler = &protocompile.Compiler{
		Resolver: &protocompile.SourceResolver{ImportPaths: []string{opts.InputDir}},
		Reporter: reporter.NewReporter(nil, nil),
	}
	c.protoDir = opts.InputDir
	c.flatbufferDir = opts.OutputDir

	if err := c.clearGoogleAPI(ctx); err != nil {
		return fmt.Errorf("could not remove google api from protos: %v", err)
	}
	if err := os.MkdirAll(c.flatbufferDir, 0755); err != nil {
		return fmt.Errorf("failed to create flatbuffers directory: %v", err)
	}
	protoFiles, err := utilities.ListFilesRelativeToRoot(c.cleanedDir, ".proto")
	if err != nil {
		return fmt.Errorf("failed to find proto files: %v", err)
	}
	if len(protoFiles) == 0 {
		return errors.New("no proto files found")
	}

	t, err := template.NewTemplate(flatbufferCommentPrefix)
	if err != nil {
		return err
	}
	comment := t.BuildCustomComment(c.getAutoGeneratedComment(t)...)

	// Delegate file processing to get a consolidated report.
	report := c.processFiles(ctx, protoFiles, comment)

	// Prepare initial logs and build the full log from the report.
	initialLogs := []string{
		"ðŸ”„ Generating FlatBuffers schemas...",
		fmt.Sprintf("   Source: %s", c.cleanedDir),
		fmt.Sprintf("   Target: %s", c.flatbufferDir),
		fmt.Sprintf("   Files to process: %d\n", len(protoFiles)),
	}
	fullLog := report.BuildFullLog(initialLogs, c.flatbufferDir)
	c.logVerbose(opts.Verbose, fullLog, report.FailedFiles)

	cleanupErr := os.RemoveAll(c.cleanedDir)
	if report.ErrorCount > 0 {
		return fmt.Errorf("conversion completed with %d errors", report.ErrorCount)
	}
	return cleanupErr
}

// processFiles iterates through proto files, converts them, and returns a report.
func (c *FlatbuffersParser) processFiles(ctx context.Context, protoFiles []string, comment string) *FileProcessingReport {
	report := NewFileProcessingReport()
	for _, protoFile := range protoFiles {
		fbsPath := path.Join(c.flatbufferDir, strings.Replace(protoFile, ".proto", ".fbs", -1))

		if err := c.convertProtoFile(ctx, protoFile); err != nil {
			report.recordFailure(protoFile, fmt.Sprintf("âœ— Failed to convert %s: %v", protoFile, err))
			continue
		}
		if err := utilities.InsertGeneratedComments(comment, fbsPath); err != nil {
			report.recordFailure(protoFile, fmt.Sprintf("âœ— Failed to add comment to %s: %v", protoFile, err))
			continue
		}
		report.recordSuccess(fmt.Sprintf("âœ“ Converted: %s", protoFile))
	}
	return report
}

// getAutoGeneratedComment returns the auto generated comment that will be placed in the fbs files
func (c *FlatbuffersParser) getAutoGeneratedComment(t *template.Template) []string {
	lines := []string{
		"DO NOT EDIT!",
		"Flatbuffers generated by Buffman ðŸ’ª",
		"Versions:",
		fmt.Sprintf("\t\tBuffman: %s", t.Buffman),
		fmt.Sprintf("\t\tFlatc: v%s", t.FlatC),
	}
	return lines
}
