// package flatbuffers contains the implementation details for generating code from
// FlatBuffer schemas. This file specifically handles the execution of the
// external 'flatc' compiler command.
package flatbuffers

import (
	"fmt"
	"os/exec"
	"path"
	"strings"

	"github.com/machanirobotics/buffman/internal/generate/language"
	"github.com/machanirobotics/buffman/internal/template"
	"github.com/machanirobotics/buffman/internal/utilities"
)

// flatcCommand is the command-line template for invoking the FlatBuffers compiler (flatc).
const flatcCommand = "flatc %s %s -o %s %s %s"

// executeCommand runs the formatted flatc command within a bash shell.
//
// It enables the `globstar` shell option, which allows for recursive file
// matching (e.g., `**/*.fbs`). This is necessary for processing schema files
// that are organized in nested directories.
//
// If the command fails, it returns an error that includes the combinebuffmand stdout
// and stderr from the command, providing context for debugging.
func executeCommand(flatbufferDir, language, includePaths, outputDir, opts string) error {
	// Construct the command string by populating the flatcCommand template.
	// The final argument uses a glob pattern to find all .fbs files recursively.
	flag := opts
	if !strings.Contains(opts, "--") && opts != "" {
		flag = "--" + opts
	}

	cmdStr := fmt.Sprintf(flatcCommand, includePaths, "--"+language, outputDir, flag, path.Join(flatbufferDir, "**/*.fbs"))

	// Prepend 'shopt -s globstar;' to enable recursive globbing for this specific command.
	// This ensures that the '**' pattern is correctly interpreted by the shell.
	fullCmd := fmt.Sprintf("shopt -s globstar; %s", cmdStr)

	// Execute the command using "bash -c" to ensure it's processed by a bash shell.
	cmd := exec.Command("bash", "-c", fullCmd)

	// Capture the combined output to provide detailed error messages.
	output, err := cmd.CombinedOutput()
	if err != nil {
		// Return a formatted error that includes the original error and the command's output.
		return fmt.Errorf("command execution failed: %v\nOutput: %s", err, string(output))
	}

	return nil
}

// generateLanguageFile orchestrates the code generation process for a single language.
// It gathers necessary include paths, executes the flatc command, and then
// post-processes the output files by inserting a "generated by" comment header.
func generateLanguageFile(flatbufferDir, outputDir, opts string, languageMetadata language.LanguageMetadata) error {
	includePaths, err := utilities.GetIncludePaths(flatbufferDir, "-I")
	if err != nil {
		return fmt.Errorf("failed to get include paths: %v", err)
	}

	if err := executeCommand(flatbufferDir, string(languageMetadata.Language), strings.Join(includePaths, " "), outputDir, opts); err != nil {
		return err
	}

	// After generation, find all newly created files with the correct extension.
	filePaths, err := utilities.ListFilesRelativeToRoot(outputDir, languageMetadata.Extension)
	if err != nil {
		return fmt.Errorf("failed to list generated files: %v", err)
	}

	// Create a comment template based on the language's comment style (e.g., //, #).
	t, err := template.NewTemplate(languageMetadata.CommentStyle)
	if err != nil {
		return err
	}
	comment := t.BuildCustomComment(getAutoGeneratedComment(t, languageMetadata.Language)...)

	// Insert the comment at the beginning of each generated file.
	for _, filePath := range filePaths {
		if err := utilities.InsertGeneratedComments(comment, path.Join(outputDir, filePath)); err != nil {
			return fmt.Errorf("failed to insert comments: %v", err)
		}
	}
	return nil
}

func getAutoGeneratedComment(t *template.Template, lang language.Language) []string {
	lines := []string{
		"DO NOT EDIT!",
		fmt.Sprintf("%s generated by Buffman ðŸ’ª", string(lang)),
		"Versions:",
		fmt.Sprintf("\t\tBuffman: %s", t.Buffman),
		fmt.Sprintf("\t\tFlatc: v%s", t.FlatC),
	}
	return lines
}
