// DO NOT EDIT!
// cpp generated by Buffman ðŸ’ª
// Versions:
//		Buffman: 1.0.0
//		Flatc: v25.2.10


#ifndef FLATBUFFERS_GENERATED_ANALYTICSSERVICE_SERVICES_H_
#define FLATBUFFERS_GENERATED_ANALYTICSSERVICE_SERVICES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "address_generated.h"
#include "status_generated.h"
#include "timestamp_generated.h"
#include "notification_service_generated.h"
#include "user_service_generated.h"

namespace services {

struct UserActivity;
struct UserActivityBuilder;

namespace UserActivity_ {

struct PropertiesEntry;
struct PropertiesEntryBuilder;

}  // namespace UserActivity_

struct NotificationMetrics;
struct NotificationMetricsBuilder;

struct UserAnalyticsRequest;
struct UserAnalyticsRequestBuilder;

struct UserAnalyticsResponse;
struct UserAnalyticsResponseBuilder;

struct SystemMetricsRequest;
struct SystemMetricsRequestBuilder;

struct SystemMetricsResponse;
struct SystemMetricsResponseBuilder;

namespace SystemMetricsResponse_ {

struct ActivityCountsEntry;
struct ActivityCountsEntryBuilder;

}  // namespace SystemMetricsResponse_

struct TrackUserActivityResponse;
struct TrackUserActivityResponseBuilder;

struct UserActivity FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserActivityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVITY_ID = 4,
    VT_USER_ID = 6,
    VT_ACTION = 8,
    VT_RESOURCE = 10,
    VT_TIMESTAMP = 12,
    VT_PROPERTIES = 14,
    VT_SESSION_ID = 16
  };
  const ::flatbuffers::String *activity_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTIVITY_ID);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const ::flatbuffers::String *action() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTION);
  }
  const ::flatbuffers::String *resource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESOURCE);
  }
  const common::Timestamp *timestamp() const {
    return GetPointer<const common::Timestamp *>(VT_TIMESTAMP);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>> *properties() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>> *>(VT_PROPERTIES);
  }
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACTIVITY_ID) &&
           verifier.VerifyString(activity_id()) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyString(action()) &&
           VerifyOffset(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffset(verifier, VT_TIMESTAMP) &&
           verifier.VerifyTable(timestamp()) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.VerifyVector(properties()) &&
           verifier.VerifyVectorOfTables(properties()) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           verifier.EndTable();
  }
};

struct UserActivityBuilder {
  typedef UserActivity Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_activity_id(::flatbuffers::Offset<::flatbuffers::String> activity_id) {
    fbb_.AddOffset(UserActivity::VT_ACTIVITY_ID, activity_id);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(UserActivity::VT_USER_ID, user_id);
  }
  void add_action(::flatbuffers::Offset<::flatbuffers::String> action) {
    fbb_.AddOffset(UserActivity::VT_ACTION, action);
  }
  void add_resource(::flatbuffers::Offset<::flatbuffers::String> resource) {
    fbb_.AddOffset(UserActivity::VT_RESOURCE, resource);
  }
  void add_timestamp(::flatbuffers::Offset<common::Timestamp> timestamp) {
    fbb_.AddOffset(UserActivity::VT_TIMESTAMP, timestamp);
  }
  void add_properties(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>>> properties) {
    fbb_.AddOffset(UserActivity::VT_PROPERTIES, properties);
  }
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(UserActivity::VT_SESSION_ID, session_id);
  }
  explicit UserActivityBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserActivity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserActivity>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserActivity> CreateUserActivity(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> activity_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> action = 0,
    ::flatbuffers::Offset<::flatbuffers::String> resource = 0,
    ::flatbuffers::Offset<common::Timestamp> timestamp = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>>> properties = 0,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0) {
  UserActivityBuilder builder_(_fbb);
  builder_.add_session_id(session_id);
  builder_.add_properties(properties);
  builder_.add_timestamp(timestamp);
  builder_.add_resource(resource);
  builder_.add_action(action);
  builder_.add_user_id(user_id);
  builder_.add_activity_id(activity_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserActivity> CreateUserActivityDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *activity_id = nullptr,
    const char *user_id = nullptr,
    const char *action = nullptr,
    const char *resource = nullptr,
    ::flatbuffers::Offset<common::Timestamp> timestamp = 0,
    const std::vector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>> *properties = nullptr,
    const char *session_id = nullptr) {
  auto activity_id__ = activity_id ? _fbb.CreateString(activity_id) : 0;
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  auto action__ = action ? _fbb.CreateString(action) : 0;
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  auto properties__ = properties ? _fbb.CreateVector<::flatbuffers::Offset<services::UserActivity_::PropertiesEntry>>(*properties) : 0;
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  return services::CreateUserActivity(
      _fbb,
      activity_id__,
      user_id__,
      action__,
      resource__,
      timestamp,
      properties__,
      session_id__);
}

namespace UserActivity_ {

struct PropertiesEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PropertiesEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct PropertiesEntryBuilder {
  typedef PropertiesEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(PropertiesEntry::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(PropertiesEntry::VT_VALUE, value);
  }
  explicit PropertiesEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PropertiesEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PropertiesEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PropertiesEntry> CreatePropertiesEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  PropertiesEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PropertiesEntry> CreatePropertiesEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return services::UserActivity_::CreatePropertiesEntry(
      _fbb,
      key__,
      value__);
}

}  // namespace UserActivity_

struct NotificationMetrics FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotificationMetricsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4,
    VT_TYPE = 6,
    VT_DELIVERED = 8,
    VT_OPENED = 10,
    VT_CLICKED = 12,
    VT_DELIVERED_AT = 14,
    VT_OPENED_AT = 16,
    VT_CLICKED_AT = 18
  };
  const ::flatbuffers::String *notification_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTIFICATION_ID);
  }
  services::NotificationType type() const {
    return static_cast<services::NotificationType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool delivered() const {
    return GetField<uint8_t>(VT_DELIVERED, 0) != 0;
  }
  bool opened() const {
    return GetField<uint8_t>(VT_OPENED, 0) != 0;
  }
  bool clicked() const {
    return GetField<uint8_t>(VT_CLICKED, 0) != 0;
  }
  const common::Timestamp *delivered_at() const {
    return GetPointer<const common::Timestamp *>(VT_DELIVERED_AT);
  }
  const common::Timestamp *opened_at() const {
    return GetPointer<const common::Timestamp *>(VT_OPENED_AT);
  }
  const common::Timestamp *clicked_at() const {
    return GetPointer<const common::Timestamp *>(VT_CLICKED_AT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFICATION_ID) &&
           verifier.VerifyString(notification_id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DELIVERED, 1) &&
           VerifyField<uint8_t>(verifier, VT_OPENED, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLICKED, 1) &&
           VerifyOffset(verifier, VT_DELIVERED_AT) &&
           verifier.VerifyTable(delivered_at()) &&
           VerifyOffset(verifier, VT_OPENED_AT) &&
           verifier.VerifyTable(opened_at()) &&
           VerifyOffset(verifier, VT_CLICKED_AT) &&
           verifier.VerifyTable(clicked_at()) &&
           verifier.EndTable();
  }
};

struct NotificationMetricsBuilder {
  typedef NotificationMetrics Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(::flatbuffers::Offset<::flatbuffers::String> notification_id) {
    fbb_.AddOffset(NotificationMetrics::VT_NOTIFICATION_ID, notification_id);
  }
  void add_type(services::NotificationType type) {
    fbb_.AddElement<int32_t>(NotificationMetrics::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_delivered(bool delivered) {
    fbb_.AddElement<uint8_t>(NotificationMetrics::VT_DELIVERED, static_cast<uint8_t>(delivered), 0);
  }
  void add_opened(bool opened) {
    fbb_.AddElement<uint8_t>(NotificationMetrics::VT_OPENED, static_cast<uint8_t>(opened), 0);
  }
  void add_clicked(bool clicked) {
    fbb_.AddElement<uint8_t>(NotificationMetrics::VT_CLICKED, static_cast<uint8_t>(clicked), 0);
  }
  void add_delivered_at(::flatbuffers::Offset<common::Timestamp> delivered_at) {
    fbb_.AddOffset(NotificationMetrics::VT_DELIVERED_AT, delivered_at);
  }
  void add_opened_at(::flatbuffers::Offset<common::Timestamp> opened_at) {
    fbb_.AddOffset(NotificationMetrics::VT_OPENED_AT, opened_at);
  }
  void add_clicked_at(::flatbuffers::Offset<common::Timestamp> clicked_at) {
    fbb_.AddOffset(NotificationMetrics::VT_CLICKED_AT, clicked_at);
  }
  explicit NotificationMetricsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NotificationMetrics> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NotificationMetrics>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NotificationMetrics> CreateNotificationMetrics(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> notification_id = 0,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    bool delivered = false,
    bool opened = false,
    bool clicked = false,
    ::flatbuffers::Offset<common::Timestamp> delivered_at = 0,
    ::flatbuffers::Offset<common::Timestamp> opened_at = 0,
    ::flatbuffers::Offset<common::Timestamp> clicked_at = 0) {
  NotificationMetricsBuilder builder_(_fbb);
  builder_.add_clicked_at(clicked_at);
  builder_.add_opened_at(opened_at);
  builder_.add_delivered_at(delivered_at);
  builder_.add_type(type);
  builder_.add_notification_id(notification_id);
  builder_.add_clicked(clicked);
  builder_.add_opened(opened);
  builder_.add_delivered(delivered);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NotificationMetrics> CreateNotificationMetricsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *notification_id = nullptr,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    bool delivered = false,
    bool opened = false,
    bool clicked = false,
    ::flatbuffers::Offset<common::Timestamp> delivered_at = 0,
    ::flatbuffers::Offset<common::Timestamp> opened_at = 0,
    ::flatbuffers::Offset<common::Timestamp> clicked_at = 0) {
  auto notification_id__ = notification_id ? _fbb.CreateString(notification_id) : 0;
  return services::CreateNotificationMetrics(
      _fbb,
      notification_id__,
      type,
      delivered,
      opened,
      clicked,
      delivered_at,
      opened_at,
      clicked_at);
}

struct UserAnalyticsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserAnalyticsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_START_DATE = 6,
    VT_END_DATE = 8
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  const common::Timestamp *start_date() const {
    return GetPointer<const common::Timestamp *>(VT_START_DATE);
  }
  const common::Timestamp *end_date() const {
    return GetPointer<const common::Timestamp *>(VT_END_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.VerifyTable(start_date()) &&
           VerifyOffset(verifier, VT_END_DATE) &&
           verifier.VerifyTable(end_date()) &&
           verifier.EndTable();
  }
};

struct UserAnalyticsRequestBuilder {
  typedef UserAnalyticsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(UserAnalyticsRequest::VT_USER_ID, user_id);
  }
  void add_start_date(::flatbuffers::Offset<common::Timestamp> start_date) {
    fbb_.AddOffset(UserAnalyticsRequest::VT_START_DATE, start_date);
  }
  void add_end_date(::flatbuffers::Offset<common::Timestamp> end_date) {
    fbb_.AddOffset(UserAnalyticsRequest::VT_END_DATE, end_date);
  }
  explicit UserAnalyticsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserAnalyticsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserAnalyticsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserAnalyticsRequest> CreateUserAnalyticsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    ::flatbuffers::Offset<common::Timestamp> start_date = 0,
    ::flatbuffers::Offset<common::Timestamp> end_date = 0) {
  UserAnalyticsRequestBuilder builder_(_fbb);
  builder_.add_end_date(end_date);
  builder_.add_start_date(start_date);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserAnalyticsRequest> CreateUserAnalyticsRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    ::flatbuffers::Offset<common::Timestamp> start_date = 0,
    ::flatbuffers::Offset<common::Timestamp> end_date = 0) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return services::CreateUserAnalyticsRequest(
      _fbb,
      user_id__,
      start_date,
      end_date);
}

struct UserAnalyticsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UserAnalyticsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER = 4,
    VT_ACTIVITIES = 6,
    VT_NOTIFICATION_METRICS = 8,
    VT_TOTAL_ACTIVITIES = 10,
    VT_TOTAL_NOTIFICATIONS_SENT = 12,
    VT_TOTAL_NOTIFICATIONS_OPENED = 14
  };
  const services::User *user() const {
    return GetPointer<const services::User *>(VT_USER);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity>> *activities() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity>> *>(VT_ACTIVITIES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::NotificationMetrics>> *notification_metrics() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::NotificationMetrics>> *>(VT_NOTIFICATION_METRICS);
  }
  int32_t total_activities() const {
    return GetField<int32_t>(VT_TOTAL_ACTIVITIES, 0);
  }
  int32_t total_notifications_sent() const {
    return GetField<int32_t>(VT_TOTAL_NOTIFICATIONS_SENT, 0);
  }
  int32_t total_notifications_opened() const {
    return GetField<int32_t>(VT_TOTAL_NOTIFICATIONS_OPENED, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER) &&
           verifier.VerifyTable(user()) &&
           VerifyOffset(verifier, VT_ACTIVITIES) &&
           verifier.VerifyVector(activities()) &&
           verifier.VerifyVectorOfTables(activities()) &&
           VerifyOffset(verifier, VT_NOTIFICATION_METRICS) &&
           verifier.VerifyVector(notification_metrics()) &&
           verifier.VerifyVectorOfTables(notification_metrics()) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_ACTIVITIES, 4) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_NOTIFICATIONS_SENT, 4) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_NOTIFICATIONS_OPENED, 4) &&
           verifier.EndTable();
  }
};

struct UserAnalyticsResponseBuilder {
  typedef UserAnalyticsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user(::flatbuffers::Offset<services::User> user) {
    fbb_.AddOffset(UserAnalyticsResponse::VT_USER, user);
  }
  void add_activities(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity>>> activities) {
    fbb_.AddOffset(UserAnalyticsResponse::VT_ACTIVITIES, activities);
  }
  void add_notification_metrics(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::NotificationMetrics>>> notification_metrics) {
    fbb_.AddOffset(UserAnalyticsResponse::VT_NOTIFICATION_METRICS, notification_metrics);
  }
  void add_total_activities(int32_t total_activities) {
    fbb_.AddElement<int32_t>(UserAnalyticsResponse::VT_TOTAL_ACTIVITIES, total_activities, 0);
  }
  void add_total_notifications_sent(int32_t total_notifications_sent) {
    fbb_.AddElement<int32_t>(UserAnalyticsResponse::VT_TOTAL_NOTIFICATIONS_SENT, total_notifications_sent, 0);
  }
  void add_total_notifications_opened(int32_t total_notifications_opened) {
    fbb_.AddElement<int32_t>(UserAnalyticsResponse::VT_TOTAL_NOTIFICATIONS_OPENED, total_notifications_opened, 0);
  }
  explicit UserAnalyticsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UserAnalyticsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UserAnalyticsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UserAnalyticsResponse> CreateUserAnalyticsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<services::User> user = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::UserActivity>>> activities = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::NotificationMetrics>>> notification_metrics = 0,
    int32_t total_activities = 0,
    int32_t total_notifications_sent = 0,
    int32_t total_notifications_opened = 0) {
  UserAnalyticsResponseBuilder builder_(_fbb);
  builder_.add_total_notifications_opened(total_notifications_opened);
  builder_.add_total_notifications_sent(total_notifications_sent);
  builder_.add_total_activities(total_activities);
  builder_.add_notification_metrics(notification_metrics);
  builder_.add_activities(activities);
  builder_.add_user(user);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UserAnalyticsResponse> CreateUserAnalyticsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<services::User> user = 0,
    const std::vector<::flatbuffers::Offset<services::UserActivity>> *activities = nullptr,
    const std::vector<::flatbuffers::Offset<services::NotificationMetrics>> *notification_metrics = nullptr,
    int32_t total_activities = 0,
    int32_t total_notifications_sent = 0,
    int32_t total_notifications_opened = 0) {
  auto activities__ = activities ? _fbb.CreateVector<::flatbuffers::Offset<services::UserActivity>>(*activities) : 0;
  auto notification_metrics__ = notification_metrics ? _fbb.CreateVector<::flatbuffers::Offset<services::NotificationMetrics>>(*notification_metrics) : 0;
  return services::CreateUserAnalyticsResponse(
      _fbb,
      user,
      activities__,
      notification_metrics__,
      total_activities,
      total_notifications_sent,
      total_notifications_opened);
}

struct SystemMetricsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemMetricsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START_DATE = 4,
    VT_END_DATE = 6
  };
  const common::Timestamp *start_date() const {
    return GetPointer<const common::Timestamp *>(VT_START_DATE);
  }
  const common::Timestamp *end_date() const {
    return GetPointer<const common::Timestamp *>(VT_END_DATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_START_DATE) &&
           verifier.VerifyTable(start_date()) &&
           VerifyOffset(verifier, VT_END_DATE) &&
           verifier.VerifyTable(end_date()) &&
           verifier.EndTable();
  }
};

struct SystemMetricsRequestBuilder {
  typedef SystemMetricsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start_date(::flatbuffers::Offset<common::Timestamp> start_date) {
    fbb_.AddOffset(SystemMetricsRequest::VT_START_DATE, start_date);
  }
  void add_end_date(::flatbuffers::Offset<common::Timestamp> end_date) {
    fbb_.AddOffset(SystemMetricsRequest::VT_END_DATE, end_date);
  }
  explicit SystemMetricsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemMetricsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemMetricsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemMetricsRequest> CreateSystemMetricsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<common::Timestamp> start_date = 0,
    ::flatbuffers::Offset<common::Timestamp> end_date = 0) {
  SystemMetricsRequestBuilder builder_(_fbb);
  builder_.add_end_date(end_date);
  builder_.add_start_date(start_date);
  return builder_.Finish();
}

struct SystemMetricsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SystemMetricsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTAL_USERS = 4,
    VT_ACTIVE_USERS = 6,
    VT_TOTAL_NOTIFICATIONS_SENT = 8,
    VT_NOTIFICATION_OPEN_RATE = 10,
    VT_ACTIVITY_COUNTS = 12,
    VT_GENERATED_AT = 14
  };
  int32_t total_users() const {
    return GetField<int32_t>(VT_TOTAL_USERS, 0);
  }
  int32_t active_users() const {
    return GetField<int32_t>(VT_ACTIVE_USERS, 0);
  }
  int32_t total_notifications_sent() const {
    return GetField<int32_t>(VT_TOTAL_NOTIFICATIONS_SENT, 0);
  }
  double notification_open_rate() const {
    return GetField<double>(VT_NOTIFICATION_OPEN_RATE, 0.0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>> *activity_counts() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>> *>(VT_ACTIVITY_COUNTS);
  }
  const common::Timestamp *generated_at() const {
    return GetPointer<const common::Timestamp *>(VT_GENERATED_AT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_USERS, 4) &&
           VerifyField<int32_t>(verifier, VT_ACTIVE_USERS, 4) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_NOTIFICATIONS_SENT, 4) &&
           VerifyField<double>(verifier, VT_NOTIFICATION_OPEN_RATE, 8) &&
           VerifyOffset(verifier, VT_ACTIVITY_COUNTS) &&
           verifier.VerifyVector(activity_counts()) &&
           verifier.VerifyVectorOfTables(activity_counts()) &&
           VerifyOffset(verifier, VT_GENERATED_AT) &&
           verifier.VerifyTable(generated_at()) &&
           verifier.EndTable();
  }
};

struct SystemMetricsResponseBuilder {
  typedef SystemMetricsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_total_users(int32_t total_users) {
    fbb_.AddElement<int32_t>(SystemMetricsResponse::VT_TOTAL_USERS, total_users, 0);
  }
  void add_active_users(int32_t active_users) {
    fbb_.AddElement<int32_t>(SystemMetricsResponse::VT_ACTIVE_USERS, active_users, 0);
  }
  void add_total_notifications_sent(int32_t total_notifications_sent) {
    fbb_.AddElement<int32_t>(SystemMetricsResponse::VT_TOTAL_NOTIFICATIONS_SENT, total_notifications_sent, 0);
  }
  void add_notification_open_rate(double notification_open_rate) {
    fbb_.AddElement<double>(SystemMetricsResponse::VT_NOTIFICATION_OPEN_RATE, notification_open_rate, 0.0);
  }
  void add_activity_counts(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>>> activity_counts) {
    fbb_.AddOffset(SystemMetricsResponse::VT_ACTIVITY_COUNTS, activity_counts);
  }
  void add_generated_at(::flatbuffers::Offset<common::Timestamp> generated_at) {
    fbb_.AddOffset(SystemMetricsResponse::VT_GENERATED_AT, generated_at);
  }
  explicit SystemMetricsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SystemMetricsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SystemMetricsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SystemMetricsResponse> CreateSystemMetricsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t total_users = 0,
    int32_t active_users = 0,
    int32_t total_notifications_sent = 0,
    double notification_open_rate = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>>> activity_counts = 0,
    ::flatbuffers::Offset<common::Timestamp> generated_at = 0) {
  SystemMetricsResponseBuilder builder_(_fbb);
  builder_.add_notification_open_rate(notification_open_rate);
  builder_.add_generated_at(generated_at);
  builder_.add_activity_counts(activity_counts);
  builder_.add_total_notifications_sent(total_notifications_sent);
  builder_.add_active_users(active_users);
  builder_.add_total_users(total_users);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SystemMetricsResponse> CreateSystemMetricsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t total_users = 0,
    int32_t active_users = 0,
    int32_t total_notifications_sent = 0,
    double notification_open_rate = 0.0,
    const std::vector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>> *activity_counts = nullptr,
    ::flatbuffers::Offset<common::Timestamp> generated_at = 0) {
  auto activity_counts__ = activity_counts ? _fbb.CreateVector<::flatbuffers::Offset<services::SystemMetricsResponse_::ActivityCountsEntry>>(*activity_counts) : 0;
  return services::CreateSystemMetricsResponse(
      _fbb,
      total_users,
      active_users,
      total_notifications_sent,
      notification_open_rate,
      activity_counts__,
      generated_at);
}

namespace SystemMetricsResponse_ {

struct ActivityCountsEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActivityCountsEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_VALUE, 4) &&
           verifier.EndTable();
  }
};

struct ActivityCountsEntryBuilder {
  typedef ActivityCountsEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(ActivityCountsEntry::VT_KEY, key);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(ActivityCountsEntry::VT_VALUE, value, 0);
  }
  explicit ActivityCountsEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActivityCountsEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActivityCountsEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ActivityCountsEntry> CreateActivityCountsEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    int32_t value = 0) {
  ActivityCountsEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ActivityCountsEntry> CreateActivityCountsEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    int32_t value = 0) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return services::SystemMetricsResponse_::CreateActivityCountsEntry(
      _fbb,
      key__,
      value);
}

}  // namespace SystemMetricsResponse_

struct TrackUserActivityResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrackUserActivityResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct TrackUserActivityResponseBuilder {
  typedef TrackUserActivityResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(TrackUserActivityResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(TrackUserActivityResponse::VT_MESSAGE, message);
  }
  explicit TrackUserActivityResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrackUserActivityResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrackUserActivityResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrackUserActivityResponse> CreateTrackUserActivityResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  TrackUserActivityResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TrackUserActivityResponse> CreateTrackUserActivityResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return services::CreateTrackUserActivityResponse(
      _fbb,
      success,
      message__);
}

namespace UserActivity_ {

}  // namespace UserActivity_

namespace SystemMetricsResponse_ {

}  // namespace SystemMetricsResponse_

}  // namespace services

#endif  // FLATBUFFERS_GENERATED_ANALYTICSSERVICE_SERVICES_H_
