// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NOTIFICATIONSERVICE_SERVICES_H_
#define FLATBUFFERS_GENERATED_NOTIFICATIONSERVICE_SERVICES_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "address_generated.h"
#include "status_generated.h"
#include "timestamp_generated.h"
#include "user_service_generated.h"

namespace services {

struct Notification;
struct NotificationBuilder;

namespace Notification_ {

struct MetadataEntry;
struct MetadataEntryBuilder;

}  // namespace Notification_

struct SendNotificationRequest;
struct SendNotificationRequestBuilder;

namespace SendNotificationRequest_ {

struct MetadataEntry;
struct MetadataEntryBuilder;

}  // namespace SendNotificationRequest_

struct SendNotificationResponse;
struct SendNotificationResponseBuilder;

struct GetUserNotificationsRequest;
struct GetUserNotificationsRequestBuilder;

struct GetUserNotificationsResponse;
struct GetUserNotificationsResponseBuilder;

struct MarkNotificationAsReadRequest;
struct MarkNotificationAsReadRequestBuilder;

struct MarkNotificationAsReadResponse;
struct MarkNotificationAsReadResponseBuilder;

enum NotificationType : int32_t {
  NotificationType_NOTIFICATION_TYPE_UNKNOWN = 0,
  NotificationType_NOTIFICATION_TYPE_EMAIL = 1,
  NotificationType_NOTIFICATION_TYPE_SMS = 2,
  NotificationType_NOTIFICATION_TYPE_PUSH = 3,
  NotificationType_NOTIFICATION_TYPE_IN_APP = 4,
  NotificationType_MIN = NotificationType_NOTIFICATION_TYPE_UNKNOWN,
  NotificationType_MAX = NotificationType_NOTIFICATION_TYPE_IN_APP
};

inline const NotificationType (&EnumValuesNotificationType())[5] {
  static const NotificationType values[] = {
    NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    NotificationType_NOTIFICATION_TYPE_EMAIL,
    NotificationType_NOTIFICATION_TYPE_SMS,
    NotificationType_NOTIFICATION_TYPE_PUSH,
    NotificationType_NOTIFICATION_TYPE_IN_APP
  };
  return values;
}

inline const char * const *EnumNamesNotificationType() {
  static const char * const names[6] = {
    "NOTIFICATION_TYPE_UNKNOWN",
    "NOTIFICATION_TYPE_EMAIL",
    "NOTIFICATION_TYPE_SMS",
    "NOTIFICATION_TYPE_PUSH",
    "NOTIFICATION_TYPE_IN_APP",
    nullptr
  };
  return names;
}

inline const char *EnumNameNotificationType(NotificationType e) {
  if (::flatbuffers::IsOutRange(e, NotificationType_NOTIFICATION_TYPE_UNKNOWN, NotificationType_NOTIFICATION_TYPE_IN_APP)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNotificationType()[index];
}

enum Priority : int32_t {
  Priority_PRIORITY_LOW = 0,
  Priority_PRIORITY_MEDIUM = 1,
  Priority_PRIORITY_HIGH = 2,
  Priority_PRIORITY_URGENT = 3,
  Priority_MIN = Priority_PRIORITY_LOW,
  Priority_MAX = Priority_PRIORITY_URGENT
};

inline const Priority (&EnumValuesPriority())[4] {
  static const Priority values[] = {
    Priority_PRIORITY_LOW,
    Priority_PRIORITY_MEDIUM,
    Priority_PRIORITY_HIGH,
    Priority_PRIORITY_URGENT
  };
  return values;
}

inline const char * const *EnumNamesPriority() {
  static const char * const names[5] = {
    "PRIORITY_LOW",
    "PRIORITY_MEDIUM",
    "PRIORITY_HIGH",
    "PRIORITY_URGENT",
    nullptr
  };
  return names;
}

inline const char *EnumNamePriority(Priority e) {
  if (::flatbuffers::IsOutRange(e, Priority_PRIORITY_LOW, Priority_PRIORITY_URGENT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPriority()[index];
}

struct Notification FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NotificationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4,
    VT_RECIPIENT_USER_ID = 6,
    VT_TYPE = 8,
    VT_TITLE = 10,
    VT_CONTENT = 12,
    VT_PRIORITY = 14,
    VT_STATUS = 16,
    VT_CREATED_AT = 18,
    VT_SENT_AT = 20,
    VT_METADATA = 22
  };
  const ::flatbuffers::String *notification_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTIFICATION_ID);
  }
  const ::flatbuffers::String *recipient_user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECIPIENT_USER_ID);
  }
  services::NotificationType type() const {
    return static_cast<services::NotificationType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  services::Priority priority() const {
    return static_cast<services::Priority>(GetField<int32_t>(VT_PRIORITY, 0));
  }
  common::Status status() const {
    return static_cast<common::Status>(GetField<int32_t>(VT_STATUS, 0));
  }
  const common::Timestamp *created_at() const {
    return GetPointer<const common::Timestamp *>(VT_CREATED_AT);
  }
  const common::Timestamp *sent_at() const {
    return GetPointer<const common::Timestamp *>(VT_SENT_AT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::Notification_::MetadataEntry>> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::Notification_::MetadataEntry>> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFICATION_ID) &&
           verifier.VerifyString(notification_id()) &&
           VerifyOffset(verifier, VT_RECIPIENT_USER_ID) &&
           verifier.VerifyString(recipient_user_id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyField<int32_t>(verifier, VT_STATUS, 4) &&
           VerifyOffset(verifier, VT_CREATED_AT) &&
           verifier.VerifyTable(created_at()) &&
           VerifyOffset(verifier, VT_SENT_AT) &&
           verifier.VerifyTable(sent_at()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           verifier.EndTable();
  }
};

struct NotificationBuilder {
  typedef Notification Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(::flatbuffers::Offset<::flatbuffers::String> notification_id) {
    fbb_.AddOffset(Notification::VT_NOTIFICATION_ID, notification_id);
  }
  void add_recipient_user_id(::flatbuffers::Offset<::flatbuffers::String> recipient_user_id) {
    fbb_.AddOffset(Notification::VT_RECIPIENT_USER_ID, recipient_user_id);
  }
  void add_type(services::NotificationType type) {
    fbb_.AddElement<int32_t>(Notification::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(Notification::VT_TITLE, title);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(Notification::VT_CONTENT, content);
  }
  void add_priority(services::Priority priority) {
    fbb_.AddElement<int32_t>(Notification::VT_PRIORITY, static_cast<int32_t>(priority), 0);
  }
  void add_status(common::Status status) {
    fbb_.AddElement<int32_t>(Notification::VT_STATUS, static_cast<int32_t>(status), 0);
  }
  void add_created_at(::flatbuffers::Offset<common::Timestamp> created_at) {
    fbb_.AddOffset(Notification::VT_CREATED_AT, created_at);
  }
  void add_sent_at(::flatbuffers::Offset<common::Timestamp> sent_at) {
    fbb_.AddOffset(Notification::VT_SENT_AT, sent_at);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::Notification_::MetadataEntry>>> metadata) {
    fbb_.AddOffset(Notification::VT_METADATA, metadata);
  }
  explicit NotificationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Notification> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Notification>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Notification> CreateNotification(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> notification_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> recipient_user_id = 0,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    services::Priority priority = services::Priority_PRIORITY_LOW,
    common::Status status = common::Status_STATUS_UNKNOWN,
    ::flatbuffers::Offset<common::Timestamp> created_at = 0,
    ::flatbuffers::Offset<common::Timestamp> sent_at = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::Notification_::MetadataEntry>>> metadata = 0) {
  NotificationBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_sent_at(sent_at);
  builder_.add_created_at(created_at);
  builder_.add_status(status);
  builder_.add_priority(priority);
  builder_.add_content(content);
  builder_.add_title(title);
  builder_.add_type(type);
  builder_.add_recipient_user_id(recipient_user_id);
  builder_.add_notification_id(notification_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Notification> CreateNotificationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *notification_id = nullptr,
    const char *recipient_user_id = nullptr,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    const char *title = nullptr,
    const char *content = nullptr,
    services::Priority priority = services::Priority_PRIORITY_LOW,
    common::Status status = common::Status_STATUS_UNKNOWN,
    ::flatbuffers::Offset<common::Timestamp> created_at = 0,
    ::flatbuffers::Offset<common::Timestamp> sent_at = 0,
    const std::vector<::flatbuffers::Offset<services::Notification_::MetadataEntry>> *metadata = nullptr) {
  auto notification_id__ = notification_id ? _fbb.CreateString(notification_id) : 0;
  auto recipient_user_id__ = recipient_user_id ? _fbb.CreateString(recipient_user_id) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<services::Notification_::MetadataEntry>>(*metadata) : 0;
  return services::CreateNotification(
      _fbb,
      notification_id__,
      recipient_user_id__,
      type,
      title__,
      content__,
      priority,
      status,
      created_at,
      sent_at,
      metadata__);
}

namespace Notification_ {

struct MetadataEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct MetadataEntryBuilder {
  typedef MetadataEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(MetadataEntry::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(MetadataEntry::VT_VALUE, value);
  }
  explicit MetadataEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetadataEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetadataEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  MetadataEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return services::Notification_::CreateMetadataEntry(
      _fbb,
      key__,
      value__);
}

}  // namespace Notification_

struct SendNotificationRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendNotificationRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RECIPIENT_USER_ID = 4,
    VT_TYPE = 6,
    VT_TITLE = 8,
    VT_CONTENT = 10,
    VT_PRIORITY = 12,
    VT_METADATA = 14
  };
  const ::flatbuffers::String *recipient_user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECIPIENT_USER_ID);
  }
  services::NotificationType type() const {
    return static_cast<services::NotificationType>(GetField<int32_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *title() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TITLE);
  }
  const ::flatbuffers::String *content() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTENT);
  }
  services::Priority priority() const {
    return static_cast<services::Priority>(GetField<int32_t>(VT_PRIORITY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>> *metadata() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>> *>(VT_METADATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RECIPIENT_USER_ID) &&
           verifier.VerifyString(recipient_user_id()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyOffset(verifier, VT_TITLE) &&
           verifier.VerifyString(title()) &&
           VerifyOffset(verifier, VT_CONTENT) &&
           verifier.VerifyString(content()) &&
           VerifyField<int32_t>(verifier, VT_PRIORITY, 4) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyVector(metadata()) &&
           verifier.VerifyVectorOfTables(metadata()) &&
           verifier.EndTable();
  }
};

struct SendNotificationRequestBuilder {
  typedef SendNotificationRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_recipient_user_id(::flatbuffers::Offset<::flatbuffers::String> recipient_user_id) {
    fbb_.AddOffset(SendNotificationRequest::VT_RECIPIENT_USER_ID, recipient_user_id);
  }
  void add_type(services::NotificationType type) {
    fbb_.AddElement<int32_t>(SendNotificationRequest::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_title(::flatbuffers::Offset<::flatbuffers::String> title) {
    fbb_.AddOffset(SendNotificationRequest::VT_TITLE, title);
  }
  void add_content(::flatbuffers::Offset<::flatbuffers::String> content) {
    fbb_.AddOffset(SendNotificationRequest::VT_CONTENT, content);
  }
  void add_priority(services::Priority priority) {
    fbb_.AddElement<int32_t>(SendNotificationRequest::VT_PRIORITY, static_cast<int32_t>(priority), 0);
  }
  void add_metadata(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>>> metadata) {
    fbb_.AddOffset(SendNotificationRequest::VT_METADATA, metadata);
  }
  explicit SendNotificationRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendNotificationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendNotificationRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SendNotificationRequest> CreateSendNotificationRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> recipient_user_id = 0,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    ::flatbuffers::Offset<::flatbuffers::String> title = 0,
    ::flatbuffers::Offset<::flatbuffers::String> content = 0,
    services::Priority priority = services::Priority_PRIORITY_LOW,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>>> metadata = 0) {
  SendNotificationRequestBuilder builder_(_fbb);
  builder_.add_metadata(metadata);
  builder_.add_priority(priority);
  builder_.add_content(content);
  builder_.add_title(title);
  builder_.add_type(type);
  builder_.add_recipient_user_id(recipient_user_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SendNotificationRequest> CreateSendNotificationRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *recipient_user_id = nullptr,
    services::NotificationType type = services::NotificationType_NOTIFICATION_TYPE_UNKNOWN,
    const char *title = nullptr,
    const char *content = nullptr,
    services::Priority priority = services::Priority_PRIORITY_LOW,
    const std::vector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>> *metadata = nullptr) {
  auto recipient_user_id__ = recipient_user_id ? _fbb.CreateString(recipient_user_id) : 0;
  auto title__ = title ? _fbb.CreateString(title) : 0;
  auto content__ = content ? _fbb.CreateString(content) : 0;
  auto metadata__ = metadata ? _fbb.CreateVector<::flatbuffers::Offset<services::SendNotificationRequest_::MetadataEntry>>(*metadata) : 0;
  return services::CreateSendNotificationRequest(
      _fbb,
      recipient_user_id__,
      type,
      title__,
      content__,
      priority,
      metadata__);
}

namespace SendNotificationRequest_ {

struct MetadataEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MetadataEntryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct MetadataEntryBuilder {
  typedef MetadataEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(MetadataEntry::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(MetadataEntry::VT_VALUE, value);
  }
  explicit MetadataEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MetadataEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MetadataEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  MetadataEntryBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MetadataEntry> CreateMetadataEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return services::SendNotificationRequest_::CreateMetadataEntry(
      _fbb,
      key__,
      value__);
}

}  // namespace SendNotificationRequest_

struct SendNotificationResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SendNotificationResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4,
    VT_SUCCESS = 6,
    VT_MESSAGE = 8
  };
  const ::flatbuffers::String *notification_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTIFICATION_ID);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFICATION_ID) &&
           verifier.VerifyString(notification_id()) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct SendNotificationResponseBuilder {
  typedef SendNotificationResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(::flatbuffers::Offset<::flatbuffers::String> notification_id) {
    fbb_.AddOffset(SendNotificationResponse::VT_NOTIFICATION_ID, notification_id);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(SendNotificationResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(SendNotificationResponse::VT_MESSAGE, message);
  }
  explicit SendNotificationResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SendNotificationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SendNotificationResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SendNotificationResponse> CreateSendNotificationResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> notification_id = 0,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  SendNotificationResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_notification_id(notification_id);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SendNotificationResponse> CreateSendNotificationResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *notification_id = nullptr,
    bool success = false,
    const char *message = nullptr) {
  auto notification_id__ = notification_id ? _fbb.CreateString(notification_id) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return services::CreateSendNotificationResponse(
      _fbb,
      notification_id__,
      success,
      message__);
}

struct GetUserNotificationsRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUserNotificationsRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USER_ID = 4,
    VT_LIMIT = 6,
    VT_OFFSET = 8,
    VT_STATUS_FILTER = 10
  };
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  int32_t limit() const {
    return GetField<int32_t>(VT_LIMIT, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  common::Status status_filter() const {
    return static_cast<common::Status>(GetField<int32_t>(VT_STATUS_FILTER, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           VerifyField<int32_t>(verifier, VT_LIMIT, 4) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<int32_t>(verifier, VT_STATUS_FILTER, 4) &&
           verifier.EndTable();
  }
};

struct GetUserNotificationsRequestBuilder {
  typedef GetUserNotificationsRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(GetUserNotificationsRequest::VT_USER_ID, user_id);
  }
  void add_limit(int32_t limit) {
    fbb_.AddElement<int32_t>(GetUserNotificationsRequest::VT_LIMIT, limit, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(GetUserNotificationsRequest::VT_OFFSET, offset, 0);
  }
  void add_status_filter(common::Status status_filter) {
    fbb_.AddElement<int32_t>(GetUserNotificationsRequest::VT_STATUS_FILTER, static_cast<int32_t>(status_filter), 0);
  }
  explicit GetUserNotificationsRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUserNotificationsRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUserNotificationsRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUserNotificationsRequest> CreateGetUserNotificationsRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0,
    int32_t limit = 0,
    int32_t offset = 0,
    common::Status status_filter = common::Status_STATUS_UNKNOWN) {
  GetUserNotificationsRequestBuilder builder_(_fbb);
  builder_.add_status_filter(status_filter);
  builder_.add_offset(offset);
  builder_.add_limit(limit);
  builder_.add_user_id(user_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetUserNotificationsRequest> CreateGetUserNotificationsRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *user_id = nullptr,
    int32_t limit = 0,
    int32_t offset = 0,
    common::Status status_filter = common::Status_STATUS_UNKNOWN) {
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return services::CreateGetUserNotificationsRequest(
      _fbb,
      user_id__,
      limit,
      offset,
      status_filter);
}

struct GetUserNotificationsResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetUserNotificationsResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATIONS = 4,
    VT_TOTAL_COUNT = 6,
    VT_USER_INFO = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<services::Notification>> *notifications() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<services::Notification>> *>(VT_NOTIFICATIONS);
  }
  int32_t total_count() const {
    return GetField<int32_t>(VT_TOTAL_COUNT, 0);
  }
  const services::User *user_info() const {
    return GetPointer<const services::User *>(VT_USER_INFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFICATIONS) &&
           verifier.VerifyVector(notifications()) &&
           verifier.VerifyVectorOfTables(notifications()) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_COUNT, 4) &&
           VerifyOffset(verifier, VT_USER_INFO) &&
           verifier.VerifyTable(user_info()) &&
           verifier.EndTable();
  }
};

struct GetUserNotificationsResponseBuilder {
  typedef GetUserNotificationsResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notifications(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::Notification>>> notifications) {
    fbb_.AddOffset(GetUserNotificationsResponse::VT_NOTIFICATIONS, notifications);
  }
  void add_total_count(int32_t total_count) {
    fbb_.AddElement<int32_t>(GetUserNotificationsResponse::VT_TOTAL_COUNT, total_count, 0);
  }
  void add_user_info(::flatbuffers::Offset<services::User> user_info) {
    fbb_.AddOffset(GetUserNotificationsResponse::VT_USER_INFO, user_info);
  }
  explicit GetUserNotificationsResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetUserNotificationsResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetUserNotificationsResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetUserNotificationsResponse> CreateGetUserNotificationsResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<services::Notification>>> notifications = 0,
    int32_t total_count = 0,
    ::flatbuffers::Offset<services::User> user_info = 0) {
  GetUserNotificationsResponseBuilder builder_(_fbb);
  builder_.add_user_info(user_info);
  builder_.add_total_count(total_count);
  builder_.add_notifications(notifications);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GetUserNotificationsResponse> CreateGetUserNotificationsResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<services::Notification>> *notifications = nullptr,
    int32_t total_count = 0,
    ::flatbuffers::Offset<services::User> user_info = 0) {
  auto notifications__ = notifications ? _fbb.CreateVector<::flatbuffers::Offset<services::Notification>>(*notifications) : 0;
  return services::CreateGetUserNotificationsResponse(
      _fbb,
      notifications__,
      total_count,
      user_info);
}

struct MarkNotificationAsReadRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MarkNotificationAsReadRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NOTIFICATION_ID = 4,
    VT_USER_ID = 6
  };
  const ::flatbuffers::String *notification_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTIFICATION_ID);
  }
  const ::flatbuffers::String *user_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USER_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NOTIFICATION_ID) &&
           verifier.VerifyString(notification_id()) &&
           VerifyOffset(verifier, VT_USER_ID) &&
           verifier.VerifyString(user_id()) &&
           verifier.EndTable();
  }
};

struct MarkNotificationAsReadRequestBuilder {
  typedef MarkNotificationAsReadRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_notification_id(::flatbuffers::Offset<::flatbuffers::String> notification_id) {
    fbb_.AddOffset(MarkNotificationAsReadRequest::VT_NOTIFICATION_ID, notification_id);
  }
  void add_user_id(::flatbuffers::Offset<::flatbuffers::String> user_id) {
    fbb_.AddOffset(MarkNotificationAsReadRequest::VT_USER_ID, user_id);
  }
  explicit MarkNotificationAsReadRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MarkNotificationAsReadRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MarkNotificationAsReadRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MarkNotificationAsReadRequest> CreateMarkNotificationAsReadRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> notification_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> user_id = 0) {
  MarkNotificationAsReadRequestBuilder builder_(_fbb);
  builder_.add_user_id(user_id);
  builder_.add_notification_id(notification_id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MarkNotificationAsReadRequest> CreateMarkNotificationAsReadRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *notification_id = nullptr,
    const char *user_id = nullptr) {
  auto notification_id__ = notification_id ? _fbb.CreateString(notification_id) : 0;
  auto user_id__ = user_id ? _fbb.CreateString(user_id) : 0;
  return services::CreateMarkNotificationAsReadRequest(
      _fbb,
      notification_id__,
      user_id__);
}

struct MarkNotificationAsReadResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MarkNotificationAsReadResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUCCESS = 4,
    VT_MESSAGE = 6
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct MarkNotificationAsReadResponseBuilder {
  typedef MarkNotificationAsReadResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(MarkNotificationAsReadResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(MarkNotificationAsReadResponse::VT_MESSAGE, message);
  }
  explicit MarkNotificationAsReadResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MarkNotificationAsReadResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MarkNotificationAsReadResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MarkNotificationAsReadResponse> CreateMarkNotificationAsReadResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  MarkNotificationAsReadResponseBuilder builder_(_fbb);
  builder_.add_message(message);
  builder_.add_success(success);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MarkNotificationAsReadResponse> CreateMarkNotificationAsReadResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return services::CreateMarkNotificationAsReadResponse(
      _fbb,
      success,
      message__);
}

namespace Notification_ {

}  // namespace Notification_

namespace SendNotificationRequest_ {

}  // namespace SendNotificationRequest_

}  // namespace services

#endif  // FLATBUFFERS_GENERATED_NOTIFICATIONSERVICE_SERVICES_H_
