// DO NOT EDIT!
// rust generated by Buffman ðŸ’ª
// Versions:
//		Buffman: 1.0.0
//		Flatc: v25.2.10


// @generated

use crate::address_generated::*;
use crate::timestamp_generated::*;
use crate::user_service_generated::*;
use crate::status_generated::*;
use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod services {

  use crate::address_generated::*;
  use crate::timestamp_generated::*;
  use crate::user_service_generated::*;
  use crate::status_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_NOTIFICATION_TYPE: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_NOTIFICATION_TYPE: i32 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_NOTIFICATION_TYPE: [NotificationType; 5] = [
  NotificationType::NOTIFICATION_TYPE_UNKNOWN,
  NotificationType::NOTIFICATION_TYPE_EMAIL,
  NotificationType::NOTIFICATION_TYPE_SMS,
  NotificationType::NOTIFICATION_TYPE_PUSH,
  NotificationType::NOTIFICATION_TYPE_IN_APP,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct NotificationType(pub i32);
#[allow(non_upper_case_globals)]
impl NotificationType {
  pub const NOTIFICATION_TYPE_UNKNOWN: Self = Self(0);
  pub const NOTIFICATION_TYPE_EMAIL: Self = Self(1);
  pub const NOTIFICATION_TYPE_SMS: Self = Self(2);
  pub const NOTIFICATION_TYPE_PUSH: Self = Self(3);
  pub const NOTIFICATION_TYPE_IN_APP: Self = Self(4);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NOTIFICATION_TYPE_UNKNOWN,
    Self::NOTIFICATION_TYPE_EMAIL,
    Self::NOTIFICATION_TYPE_SMS,
    Self::NOTIFICATION_TYPE_PUSH,
    Self::NOTIFICATION_TYPE_IN_APP,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NOTIFICATION_TYPE_UNKNOWN => Some("NOTIFICATION_TYPE_UNKNOWN"),
      Self::NOTIFICATION_TYPE_EMAIL => Some("NOTIFICATION_TYPE_EMAIL"),
      Self::NOTIFICATION_TYPE_SMS => Some("NOTIFICATION_TYPE_SMS"),
      Self::NOTIFICATION_TYPE_PUSH => Some("NOTIFICATION_TYPE_PUSH"),
      Self::NOTIFICATION_TYPE_IN_APP => Some("NOTIFICATION_TYPE_IN_APP"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for NotificationType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for NotificationType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for NotificationType {
    type Output = NotificationType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for NotificationType {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for NotificationType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for NotificationType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_PRIORITY: i32 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_PRIORITY: i32 = 3;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_PRIORITY: [Priority; 4] = [
  Priority::PRIORITY_LOW,
  Priority::PRIORITY_MEDIUM,
  Priority::PRIORITY_HIGH,
  Priority::PRIORITY_URGENT,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Priority(pub i32);
#[allow(non_upper_case_globals)]
impl Priority {
  pub const PRIORITY_LOW: Self = Self(0);
  pub const PRIORITY_MEDIUM: Self = Self(1);
  pub const PRIORITY_HIGH: Self = Self(2);
  pub const PRIORITY_URGENT: Self = Self(3);

  pub const ENUM_MIN: i32 = 0;
  pub const ENUM_MAX: i32 = 3;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::PRIORITY_LOW,
    Self::PRIORITY_MEDIUM,
    Self::PRIORITY_HIGH,
    Self::PRIORITY_URGENT,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::PRIORITY_LOW => Some("PRIORITY_LOW"),
      Self::PRIORITY_MEDIUM => Some("PRIORITY_MEDIUM"),
      Self::PRIORITY_HIGH => Some("PRIORITY_HIGH"),
      Self::PRIORITY_URGENT => Some("PRIORITY_URGENT"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Priority {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Priority {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i32>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Priority {
    type Output = Priority;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i32>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Priority {
  type Scalar = i32;
  #[inline]
  fn to_little_endian(self) -> i32 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i32) -> Self {
    let b = i32::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Priority {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i32::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Priority {}
pub enum NotificationOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Notification<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Notification<'a> {
  type Inner = Notification<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Notification<'a> {
  pub const VT_NOTIFICATION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_RECIPIENT_USER_ID: flatbuffers::VOffsetT = 6;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 8;
  pub const VT_TITLE: flatbuffers::VOffsetT = 10;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 12;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 14;
  pub const VT_STATUS: flatbuffers::VOffsetT = 16;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 18;
  pub const VT_SENT_AT: flatbuffers::VOffsetT = 20;
  pub const VT_METADATA: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Notification { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args NotificationArgs<'args>
  ) -> flatbuffers::WIPOffset<Notification<'bldr>> {
    let mut builder = NotificationBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    if let Some(x) = args.sent_at { builder.add_sent_at(x); }
    if let Some(x) = args.created_at { builder.add_created_at(x); }
    builder.add_status(args.status);
    builder.add_priority(args.priority);
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.add_type_(args.type_);
    if let Some(x) = args.recipient_user_id { builder.add_recipient_user_id(x); }
    if let Some(x) = args.notification_id { builder.add_notification_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn notification_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_NOTIFICATION_ID, None)}
  }
  #[inline]
  pub fn recipient_user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_RECIPIENT_USER_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> NotificationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NotificationType>(Notification::VT_TYPE_, Some(NotificationType::NOTIFICATION_TYPE_UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_TITLE, None)}
  }
  #[inline]
  pub fn content(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Notification::VT_CONTENT, None)}
  }
  #[inline]
  pub fn priority(&self) -> Priority {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Priority>(Notification::VT_PRIORITY, Some(Priority::PRIORITY_LOW)).unwrap()}
  }
  #[inline]
  pub fn status(&self) -> super::common::Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Status>(Notification::VT_STATUS, Some(super::common::Status::STATUS_UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> Option<super::common::Timestamp<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::Timestamp>>(Notification::VT_CREATED_AT, None)}
  }
  #[inline]
  pub fn sent_at(&self) -> Option<super::common::Timestamp<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<super::common::Timestamp>>(Notification::VT_SENT_AT, None)}
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<notification_::MetadataEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<notification_::MetadataEntry>>>>(Notification::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for Notification<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notification_id", Self::VT_NOTIFICATION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient_user_id", Self::VT_RECIPIENT_USER_ID, false)?
     .visit_field::<NotificationType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
     .visit_field::<Priority>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<super::common::Status>("status", Self::VT_STATUS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::Timestamp>>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<super::common::Timestamp>>("sent_at", Self::VT_SENT_AT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<notification_::MetadataEntry>>>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct NotificationArgs<'a> {
    pub notification_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub recipient_user_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: NotificationType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: Priority,
    pub status: super::common::Status,
    pub created_at: Option<flatbuffers::WIPOffset<super::common::Timestamp<'a>>>,
    pub sent_at: Option<flatbuffers::WIPOffset<super::common::Timestamp<'a>>>,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<notification_::MetadataEntry<'a>>>>>,
}
impl<'a> Default for NotificationArgs<'a> {
  #[inline]
  fn default() -> Self {
    NotificationArgs {
      notification_id: None,
      recipient_user_id: None,
      type_: NotificationType::NOTIFICATION_TYPE_UNKNOWN,
      title: None,
      content: None,
      priority: Priority::PRIORITY_LOW,
      status: super::common::Status::STATUS_UNKNOWN,
      created_at: None,
      sent_at: None,
      metadata: None,
    }
  }
}

pub struct NotificationBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> NotificationBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_notification_id(&mut self, notification_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_NOTIFICATION_ID, notification_id);
  }
  #[inline]
  pub fn add_recipient_user_id(&mut self, recipient_user_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_RECIPIENT_USER_ID, recipient_user_id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: NotificationType) {
    self.fbb_.push_slot::<NotificationType>(Notification::VT_TYPE_, type_, NotificationType::NOTIFICATION_TYPE_UNKNOWN);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_TITLE, title);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: Priority) {
    self.fbb_.push_slot::<Priority>(Notification::VT_PRIORITY, priority, Priority::PRIORITY_LOW);
  }
  #[inline]
  pub fn add_status(&mut self, status: super::common::Status) {
    self.fbb_.push_slot::<super::common::Status>(Notification::VT_STATUS, status, super::common::Status::STATUS_UNKNOWN);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: flatbuffers::WIPOffset<super::common::Timestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::Timestamp>>(Notification::VT_CREATED_AT, created_at);
  }
  #[inline]
  pub fn add_sent_at(&mut self, sent_at: flatbuffers::WIPOffset<super::common::Timestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::common::Timestamp>>(Notification::VT_SENT_AT, sent_at);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<notification_::MetadataEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Notification::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> NotificationBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    NotificationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Notification<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Notification<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Notification");
      ds.field("notification_id", &self.notification_id());
      ds.field("recipient_user_id", &self.recipient_user_id());
      ds.field("type_", &self.type_());
      ds.field("title", &self.title());
      ds.field("content", &self.content());
      ds.field("priority", &self.priority());
      ds.field("status", &self.status());
      ds.field("created_at", &self.created_at());
      ds.field("sent_at", &self.sent_at());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum SendNotificationRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendNotificationRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendNotificationRequest<'a> {
  type Inner = SendNotificationRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SendNotificationRequest<'a> {
  pub const VT_RECIPIENT_USER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 6;
  pub const VT_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 10;
  pub const VT_PRIORITY: flatbuffers::VOffsetT = 12;
  pub const VT_METADATA: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SendNotificationRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SendNotificationRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<SendNotificationRequest<'bldr>> {
    let mut builder = SendNotificationRequestBuilder::new(_fbb);
    if let Some(x) = args.metadata { builder.add_metadata(x); }
    builder.add_priority(args.priority);
    if let Some(x) = args.content { builder.add_content(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.add_type_(args.type_);
    if let Some(x) = args.recipient_user_id { builder.add_recipient_user_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn recipient_user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SendNotificationRequest::VT_RECIPIENT_USER_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> NotificationType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<NotificationType>(SendNotificationRequest::VT_TYPE_, Some(NotificationType::NOTIFICATION_TYPE_UNKNOWN)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SendNotificationRequest::VT_TITLE, None)}
  }
  #[inline]
  pub fn content(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SendNotificationRequest::VT_CONTENT, None)}
  }
  #[inline]
  pub fn priority(&self) -> Priority {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Priority>(SendNotificationRequest::VT_PRIORITY, Some(Priority::PRIORITY_LOW)).unwrap()}
  }
  #[inline]
  pub fn metadata(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<send_notification_request_::MetadataEntry<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<send_notification_request_::MetadataEntry>>>>(SendNotificationRequest::VT_METADATA, None)}
  }
}

impl flatbuffers::Verifiable for SendNotificationRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("recipient_user_id", Self::VT_RECIPIENT_USER_ID, false)?
     .visit_field::<NotificationType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("content", Self::VT_CONTENT, false)?
     .visit_field::<Priority>("priority", Self::VT_PRIORITY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<send_notification_request_::MetadataEntry>>>>("metadata", Self::VT_METADATA, false)?
     .finish();
    Ok(())
  }
}
pub struct SendNotificationRequestArgs<'a> {
    pub recipient_user_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: NotificationType,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub content: Option<flatbuffers::WIPOffset<&'a str>>,
    pub priority: Priority,
    pub metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<send_notification_request_::MetadataEntry<'a>>>>>,
}
impl<'a> Default for SendNotificationRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    SendNotificationRequestArgs {
      recipient_user_id: None,
      type_: NotificationType::NOTIFICATION_TYPE_UNKNOWN,
      title: None,
      content: None,
      priority: Priority::PRIORITY_LOW,
      metadata: None,
    }
  }
}

pub struct SendNotificationRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendNotificationRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_recipient_user_id(&mut self, recipient_user_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationRequest::VT_RECIPIENT_USER_ID, recipient_user_id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: NotificationType) {
    self.fbb_.push_slot::<NotificationType>(SendNotificationRequest::VT_TYPE_, type_, NotificationType::NOTIFICATION_TYPE_UNKNOWN);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationRequest::VT_TITLE, title);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationRequest::VT_CONTENT, content);
  }
  #[inline]
  pub fn add_priority(&mut self, priority: Priority) {
    self.fbb_.push_slot::<Priority>(SendNotificationRequest::VT_PRIORITY, priority, Priority::PRIORITY_LOW);
  }
  #[inline]
  pub fn add_metadata(&mut self, metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<send_notification_request_::MetadataEntry<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationRequest::VT_METADATA, metadata);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SendNotificationRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SendNotificationRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendNotificationRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SendNotificationRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SendNotificationRequest");
      ds.field("recipient_user_id", &self.recipient_user_id());
      ds.field("type_", &self.type_());
      ds.field("title", &self.title());
      ds.field("content", &self.content());
      ds.field("priority", &self.priority());
      ds.field("metadata", &self.metadata());
      ds.finish()
  }
}
pub enum SendNotificationResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SendNotificationResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SendNotificationResponse<'a> {
  type Inner = SendNotificationResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SendNotificationResponse<'a> {
  pub const VT_NOTIFICATION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_SUCCESS: flatbuffers::VOffsetT = 6;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SendNotificationResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SendNotificationResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<SendNotificationResponse<'bldr>> {
    let mut builder = SendNotificationResponseBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    if let Some(x) = args.notification_id { builder.add_notification_id(x); }
    builder.add_success(args.success);
    builder.finish()
  }


  #[inline]
  pub fn notification_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SendNotificationResponse::VT_NOTIFICATION_ID, None)}
  }
  #[inline]
  pub fn success(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SendNotificationResponse::VT_SUCCESS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SendNotificationResponse::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for SendNotificationResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notification_id", Self::VT_NOTIFICATION_ID, false)?
     .visit_field::<bool>("success", Self::VT_SUCCESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct SendNotificationResponseArgs<'a> {
    pub notification_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub success: bool,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SendNotificationResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    SendNotificationResponseArgs {
      notification_id: None,
      success: false,
      message: None,
    }
  }
}

pub struct SendNotificationResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendNotificationResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_notification_id(&mut self, notification_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationResponse::VT_NOTIFICATION_ID, notification_id);
  }
  #[inline]
  pub fn add_success(&mut self, success: bool) {
    self.fbb_.push_slot::<bool>(SendNotificationResponse::VT_SUCCESS, success, false);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SendNotificationResponse::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SendNotificationResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SendNotificationResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SendNotificationResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SendNotificationResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SendNotificationResponse");
      ds.field("notification_id", &self.notification_id());
      ds.field("success", &self.success());
      ds.field("message", &self.message());
      ds.finish()
  }
}
pub enum GetUserNotificationsRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetUserNotificationsRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetUserNotificationsRequest<'a> {
  type Inner = GetUserNotificationsRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetUserNotificationsRequest<'a> {
  pub const VT_USER_ID: flatbuffers::VOffsetT = 4;
  pub const VT_LIMIT: flatbuffers::VOffsetT = 6;
  pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
  pub const VT_STATUS_FILTER: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetUserNotificationsRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetUserNotificationsRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<GetUserNotificationsRequest<'bldr>> {
    let mut builder = GetUserNotificationsRequestBuilder::new(_fbb);
    builder.add_status_filter(args.status_filter);
    builder.add_offset(args.offset);
    builder.add_limit(args.limit);
    if let Some(x) = args.user_id { builder.add_user_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(GetUserNotificationsRequest::VT_USER_ID, None)}
  }
  #[inline]
  pub fn limit(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GetUserNotificationsRequest::VT_LIMIT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn offset(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GetUserNotificationsRequest::VT_OFFSET, Some(0)).unwrap()}
  }
  #[inline]
  pub fn status_filter(&self) -> super::common::Status {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<super::common::Status>(GetUserNotificationsRequest::VT_STATUS_FILTER, Some(super::common::Status::STATUS_UNKNOWN)).unwrap()}
  }
}

impl flatbuffers::Verifiable for GetUserNotificationsRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("user_id", Self::VT_USER_ID, false)?
     .visit_field::<i32>("limit", Self::VT_LIMIT, false)?
     .visit_field::<i32>("offset", Self::VT_OFFSET, false)?
     .visit_field::<super::common::Status>("status_filter", Self::VT_STATUS_FILTER, false)?
     .finish();
    Ok(())
  }
}
pub struct GetUserNotificationsRequestArgs<'a> {
    pub user_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub limit: i32,
    pub offset: i32,
    pub status_filter: super::common::Status,
}
impl<'a> Default for GetUserNotificationsRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetUserNotificationsRequestArgs {
      user_id: None,
      limit: 0,
      offset: 0,
      status_filter: super::common::Status::STATUS_UNKNOWN,
    }
  }
}

pub struct GetUserNotificationsRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetUserNotificationsRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user_id(&mut self, user_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetUserNotificationsRequest::VT_USER_ID, user_id);
  }
  #[inline]
  pub fn add_limit(&mut self, limit: i32) {
    self.fbb_.push_slot::<i32>(GetUserNotificationsRequest::VT_LIMIT, limit, 0);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: i32) {
    self.fbb_.push_slot::<i32>(GetUserNotificationsRequest::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_status_filter(&mut self, status_filter: super::common::Status) {
    self.fbb_.push_slot::<super::common::Status>(GetUserNotificationsRequest::VT_STATUS_FILTER, status_filter, super::common::Status::STATUS_UNKNOWN);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetUserNotificationsRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetUserNotificationsRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetUserNotificationsRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetUserNotificationsRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetUserNotificationsRequest");
      ds.field("user_id", &self.user_id());
      ds.field("limit", &self.limit());
      ds.field("offset", &self.offset());
      ds.field("status_filter", &self.status_filter());
      ds.finish()
  }
}
pub enum GetUserNotificationsResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct GetUserNotificationsResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GetUserNotificationsResponse<'a> {
  type Inner = GetUserNotificationsResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> GetUserNotificationsResponse<'a> {
  pub const VT_NOTIFICATIONS: flatbuffers::VOffsetT = 4;
  pub const VT_TOTAL_COUNT: flatbuffers::VOffsetT = 6;
  pub const VT_USER_INFO: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    GetUserNotificationsResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GetUserNotificationsResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<GetUserNotificationsResponse<'bldr>> {
    let mut builder = GetUserNotificationsResponseBuilder::new(_fbb);
    if let Some(x) = args.user_info { builder.add_user_info(x); }
    builder.add_total_count(args.total_count);
    if let Some(x) = args.notifications { builder.add_notifications(x); }
    builder.finish()
  }


  #[inline]
  pub fn notifications(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Notification<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Notification>>>>(GetUserNotificationsResponse::VT_NOTIFICATIONS, None)}
  }
  #[inline]
  pub fn total_count(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(GetUserNotificationsResponse::VT_TOTAL_COUNT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn user_info(&self) -> Option<User<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<User>>(GetUserNotificationsResponse::VT_USER_INFO, None)}
  }
}

impl flatbuffers::Verifiable for GetUserNotificationsResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Notification>>>>("notifications", Self::VT_NOTIFICATIONS, false)?
     .visit_field::<i32>("total_count", Self::VT_TOTAL_COUNT, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<User>>("user_info", Self::VT_USER_INFO, false)?
     .finish();
    Ok(())
  }
}
pub struct GetUserNotificationsResponseArgs<'a> {
    pub notifications: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Notification<'a>>>>>,
    pub total_count: i32,
    pub user_info: Option<flatbuffers::WIPOffset<User<'a>>>,
}
impl<'a> Default for GetUserNotificationsResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    GetUserNotificationsResponseArgs {
      notifications: None,
      total_count: 0,
      user_info: None,
    }
  }
}

pub struct GetUserNotificationsResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> GetUserNotificationsResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_notifications(&mut self, notifications: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Notification<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GetUserNotificationsResponse::VT_NOTIFICATIONS, notifications);
  }
  #[inline]
  pub fn add_total_count(&mut self, total_count: i32) {
    self.fbb_.push_slot::<i32>(GetUserNotificationsResponse::VT_TOTAL_COUNT, total_count, 0);
  }
  #[inline]
  pub fn add_user_info(&mut self, user_info: flatbuffers::WIPOffset<User<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<User>>(GetUserNotificationsResponse::VT_USER_INFO, user_info);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> GetUserNotificationsResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GetUserNotificationsResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GetUserNotificationsResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for GetUserNotificationsResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("GetUserNotificationsResponse");
      ds.field("notifications", &self.notifications());
      ds.field("total_count", &self.total_count());
      ds.field("user_info", &self.user_info());
      ds.finish()
  }
}
pub enum MarkNotificationAsReadRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MarkNotificationAsReadRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MarkNotificationAsReadRequest<'a> {
  type Inner = MarkNotificationAsReadRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MarkNotificationAsReadRequest<'a> {
  pub const VT_NOTIFICATION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_USER_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MarkNotificationAsReadRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MarkNotificationAsReadRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<MarkNotificationAsReadRequest<'bldr>> {
    let mut builder = MarkNotificationAsReadRequestBuilder::new(_fbb);
    if let Some(x) = args.user_id { builder.add_user_id(x); }
    if let Some(x) = args.notification_id { builder.add_notification_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn notification_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MarkNotificationAsReadRequest::VT_NOTIFICATION_ID, None)}
  }
  #[inline]
  pub fn user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MarkNotificationAsReadRequest::VT_USER_ID, None)}
  }
}

impl flatbuffers::Verifiable for MarkNotificationAsReadRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("notification_id", Self::VT_NOTIFICATION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("user_id", Self::VT_USER_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct MarkNotificationAsReadRequestArgs<'a> {
    pub notification_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub user_id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MarkNotificationAsReadRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    MarkNotificationAsReadRequestArgs {
      notification_id: None,
      user_id: None,
    }
  }
}

pub struct MarkNotificationAsReadRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MarkNotificationAsReadRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_notification_id(&mut self, notification_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MarkNotificationAsReadRequest::VT_NOTIFICATION_ID, notification_id);
  }
  #[inline]
  pub fn add_user_id(&mut self, user_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MarkNotificationAsReadRequest::VT_USER_ID, user_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MarkNotificationAsReadRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MarkNotificationAsReadRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MarkNotificationAsReadRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MarkNotificationAsReadRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MarkNotificationAsReadRequest");
      ds.field("notification_id", &self.notification_id());
      ds.field("user_id", &self.user_id());
      ds.finish()
  }
}
pub enum MarkNotificationAsReadResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MarkNotificationAsReadResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MarkNotificationAsReadResponse<'a> {
  type Inner = MarkNotificationAsReadResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MarkNotificationAsReadResponse<'a> {
  pub const VT_SUCCESS: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MarkNotificationAsReadResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MarkNotificationAsReadResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<MarkNotificationAsReadResponse<'bldr>> {
    let mut builder = MarkNotificationAsReadResponseBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_success(args.success);
    builder.finish()
  }


  #[inline]
  pub fn success(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(MarkNotificationAsReadResponse::VT_SUCCESS, Some(false)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MarkNotificationAsReadResponse::VT_MESSAGE, None)}
  }
}

impl flatbuffers::Verifiable for MarkNotificationAsReadResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<bool>("success", Self::VT_SUCCESS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("message", Self::VT_MESSAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct MarkNotificationAsReadResponseArgs<'a> {
    pub success: bool,
    pub message: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MarkNotificationAsReadResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    MarkNotificationAsReadResponseArgs {
      success: false,
      message: None,
    }
  }
}

pub struct MarkNotificationAsReadResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MarkNotificationAsReadResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_success(&mut self, success: bool) {
    self.fbb_.push_slot::<bool>(MarkNotificationAsReadResponse::VT_SUCCESS, success, false);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MarkNotificationAsReadResponse::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MarkNotificationAsReadResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MarkNotificationAsReadResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MarkNotificationAsReadResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MarkNotificationAsReadResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MarkNotificationAsReadResponse");
      ds.field("success", &self.success());
      ds.field("message", &self.message());
      ds.finish()
  }
}
#[allow(unused_imports, dead_code)]
pub mod notification_ {

  use crate::address_generated::*;
  use crate::timestamp_generated::*;
  use crate::user_service_generated::*;
  use crate::status_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MetadataEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MetadataEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataEntry<'a> {
  type Inner = MetadataEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MetadataEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MetadataEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MetadataEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<MetadataEntry<'bldr>> {
    let mut builder = MetadataEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetadataEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetadataEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for MetadataEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MetadataEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetadataEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct MetadataEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MetadataEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MetadataEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetadataEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MetadataEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MetadataEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
}  // pub mod Notification_

#[allow(unused_imports, dead_code)]
pub mod send_notification_request_ {

  use crate::address_generated::*;
  use crate::timestamp_generated::*;
  use crate::user_service_generated::*;
  use crate::status_generated::*;
  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

pub enum MetadataEntryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct MetadataEntry<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for MetadataEntry<'a> {
  type Inner = MetadataEntry<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> MetadataEntry<'a> {
  pub const VT_KEY: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    MetadataEntry { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MetadataEntryArgs<'args>
  ) -> flatbuffers::WIPOffset<MetadataEntry<'bldr>> {
    let mut builder = MetadataEntryBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.key { builder.add_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn key(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetadataEntry::VT_KEY, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(MetadataEntry::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for MetadataEntry<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("key", Self::VT_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct MetadataEntryArgs<'a> {
    pub key: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for MetadataEntryArgs<'a> {
  #[inline]
  fn default() -> Self {
    MetadataEntryArgs {
      key: None,
      value: None,
    }
  }
}

pub struct MetadataEntryBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MetadataEntryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataEntry::VT_KEY, key);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(MetadataEntry::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MetadataEntryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MetadataEntryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<MetadataEntry<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for MetadataEntry<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("MetadataEntry");
      ds.field("key", &self.key());
      ds.field("value", &self.value());
      ds.finish()
  }
}
}  // pub mod SendNotificationRequest_
}  // pub mod services

